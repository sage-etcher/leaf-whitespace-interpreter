
        /* instructions */
        if (strncmp (instruction, WS_INST[inst_check = WS_PUSH], strlen (WS_INST[inst_check])) == 0)
        {   /* push value onto stack SSNL */
            ws_err_code = wsi_push (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_DUP], strlen (WS_INST[inst_check])) == 0)
        {   /* duplicate top value of stack SLS */
            ws_err_code = wsi_dup (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_COPY], strlen (WS_INST[inst_check])) == 0)
        {   /* copy item to the top of the stack */
            ws_err_code = wsi_copy (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_SWAP], strlen (WS_INST[inst_check])) == 0)
        {   /* swap top 2 items on stack */
            ws_err_code = wsi_swap (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_POP], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_pop (&program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_SLIDE], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_slide (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_ADD], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_add (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_SUB], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_sub (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_MULT], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_mult (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_DIV], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_idiv (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_MOD], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_mod (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_STORE], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_store (program_stack, &program_stack_index, program_heap);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_RESTORE], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_restore (program_stack, &program_stack_index, program_heap);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_LABEL], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_label (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_CALL], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_call (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_JMP], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_jump (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_JZ], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_jump_zero (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_JN], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_jump_negative (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_RET], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_ret (&program_counter_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_END], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_end (&runtime);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_PUTC], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_putc (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_PUTI], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_puti (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_READC], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_readc (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_READI], strlen (WS_INST[inst_check])) == 0)
        {
            ws_err_code = wsi_readi (program_stack, &program_stack_index);
            ws_last_instruction = inst_check;
        }
        else if (strncmp (instruction, WS_INST[inst_check = WS_DPRINT], strlen (WS_INST[inst_check])) == 0)
        {
            print_stack (program_stack, program_stack_index);
            ws_last_instruction = inst_check;
        }
        else
        {
            instruction_flag = false;
            inst_check = WS_NONE
        }









        /* instructions */
        if (strncmp (instruction, WS_INST[WS_PUSH], strlen (WS_INST[WS_PUSH])) == 0)
        {   /* push value onto stack SSNL */
            ws_err_code = wsi_push (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = WS_PUSH;
        }
        else if (strncmp (instruction, WS_INST[WS_DUP], strlen (WS_INST[WS_DUP])) == 0)
        {   /* duplicate top value of stack SLS */
            ws_err_code = wsi_dup (program_stack, &program_stack_index);
            ws_last_instruction = WS_DUP;
        }
        else if (strncmp (instruction, WS_INST[WS_COPY], strlen (WS_INST[WS_COPY])) == 0)
        {   /* copy item to the top of the stack */
            ws_err_code = wsi_copy (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = WS_COPY;
        }
        else if (strncmp (instruction, WS_INST[WS_SWAP], strlen (WS_INST[WS_SWAP])) == 0)
        {   /* swap top 2 items on stack */
            ws_err_code = wsi_swap (program_stack, &program_stack_index);
            ws_last_instruction = WS_SWAP;
        }
        else if (strncmp (instruction, WS_INST[WS_POP], strlen (WS_INST[WS_POP])) == 0)
        {
            ws_err_code = wsi_pop (&program_stack_index);
            ws_last_instruction = WS_POP;
        }
        else if (strncmp (instruction, WS_INST[WS_SLIDE], strlen (WS_INST[WS_SLIDE])) == 0)
        {
            ws_err_code = wsi_slide (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = WS_SLIDE;
        }
        else if (strncmp (instruction, WS_INST[WS_ADD], strlen (WS_INST[WS_ADD])) == 0)
        {
            ws_err_code = wsi_add (program_stack, &program_stack_index);
            ws_last_instruction = WS_ADD;
        }
        else if (strncmp (instruction, WS_INST[WS_SUB], strlen (WS_INST[WS_SUB])) == 0)
        {
            ws_err_code = wsi_sub (program_stack, &program_stack_index);
            ws_last_instruction = WS_SUB;
        }
        else if (strncmp (instruction, WS_INST[WS_MULT], strlen (WS_INST[WS_MULT])) == 0)
        {
            ws_err_code = wsi_mult (program_stack, &program_stack_index);
            ws_last_instruction = WS_MULT;
        }
        else if (strncmp (instruction, WS_INST[WS_DIV], strlen (WS_INST[WS_DIV])) == 0)
        {
            ws_err_code = wsi_idiv (program_stack, &program_stack_index);
            ws_last_instruction = WS_DIV;
        }
        else if (strncmp (instruction, WS_INST[WS_MOD], strlen (WS_INST[WS_MOD])) == 0)
        {
            ws_err_code = wsi_mod (program_stack, &program_stack_index);
            ws_last_instruction = WS_MOD;
        }
        else if (strncmp (instruction, WS_INST[WS_STORE], strlen (WS_INST[WS_STORE])) == 0)
        {
            ws_err_code = wsi_store (program_stack, &program_stack_index, program_heap);
            ws_last_instruction = WS_STORE;
        }
        else if (strncmp (instruction, WS_INST[WS_RESTORE], strlen (WS_INST[WS_RESTORE])) == 0)
        {
            ws_err_code = wsi_restore (program_stack, &program_stack_index, program_heap);
            ws_last_instruction = WS_RESTORE;
        }
        else if (strncmp (instruction, WS_INST[WS_LABEL], strlen (WS_INST[WS_LABEL])) == 0)
        {
            ws_err_code = wsi_label (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = WS_LABEL;
        }
        else if (strncmp (instruction, WS_INST[WS_CALL], strlen (WS_INST[WS_CALL])) == 0)
        {
            ws_err_code = wsi_call (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = WS_CALL;
        }
        else if (strncmp (instruction, WS_INST[WS_JMP], strlen (WS_INST[WS_JMP])) == 0)
        {
            ws_err_code = wsi_jump (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = WS_JMP;
        }
        else if (strncmp (instruction, WS_INST[WS_JZ], strlen (WS_INST[WS_JZ])) == 0)
        {
            ws_err_code = wsi_jump_zero (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = WS_JZ;
        }
        else if (strncmp (instruction, WS_INST[WS_JN], strlen (WS_INST[WS_JN])) == 0)
        {
            ws_err_code = wsi_jump_negative (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
            ws_last_instruction = WS_JN;
        }
        else if (strncmp (instruction, WS_INST[WS_RET], strlen (WS_INST[WS_RET])) == 0)
        {
            ws_err_code = wsi_ret (&program_counter_index);
            ws_last_instruction = WS_RET;
        }
        else if (strncmp (instruction, WS_INST[WS_END], strlen (WS_INST[WS_END])) == 0)
        {
            ws_err_code = wsi_end (&runtime);
            ws_last_instruction = WS_END;
        }
        else if (strncmp (instruction, WS_INST[WS_PUTC], strlen (WS_INST[WS_PUTC])) == 0)
        {
            ws_err_code = wsi_putc (program_stack, &program_stack_index);
            ws_last_instruction = WS_PUTC;
        }
        else if (strncmp (instruction, WS_INST[WS_PUTI], strlen (WS_INST[WS_PUTI])) == 0)
        {
            ws_err_code = wsi_puti (program_stack, &program_stack_index);
            ws_last_instruction = WS_PUTI;
        }
        else if (strncmp (instruction, WS_INST[WS_READC], strlen (WS_INST[WS_READC])) == 0)
        {
            ws_err_code = wsi_readc (program_stack, &program_stack_index);
            ws_last_instruction = WS_READC;
        }
        else if (strncmp (instruction, WS_INST[WS_READI], strlen (WS_INST[WS_READI])) == 0)
        {
            ws_err_code = wsi_readi (program_stack, &program_stack_index);
            ws_last_instruction = WS_READI;
        }
        else if (strncmp (instruction, WS_INST[WS_DPRINT], strlen (WS_INST[WS_DPRINT])) == 0)
        {
            print_stack (program_stack, program_stack_index);
            ws_last_instruction = WS_DPRINT;
        }
        else
        {
            instruction_flag = false;
        }








/* instruction command */
const char *WS_INST[] =
{
/* WS_PUSH    */ "  ",         /*  SS  N L  push [num] onto stack */
/* WS_DUP     */ " \n ",       /*  SLS      duplicate top value on stack */
/* WS_COPY    */ " \t ",       /*  STS N L  copy the [n]th element on stack to the top */
/* WS_SWAP    */ " \n\t",      /*  SLT      swaps the top 2 elements of the stack */
/* WS_POP     */ " \n\n",      /*  SLL      destroys top element on the stack */
/* WS_SLIDE   */ " \t\n",      /*  STL N L  destroy [n] elements off the stack, keep top element */
/* WS_ADD     */ "\t   ",      /*  TSSS     addition */
/* WS_SUB     */ "\t  \t",     /*  TSST     subtraction */
/* WS_MULT    */ "\t  \n",     /*  TSSL     multiplication */
/* WS_DIV     */ "\t \t ",     /*  TSTS     integer division */
/* WS_MOD     */ "\t \t\t",    /*  TSTT     modulo */
/* WS_STORE   */ "\t\t ",      /*  TTS      store in heap */
/* WS_RESTORE */ "\t\t\t",     /*  TTT      restore from heap */
/* WS_LABEL   */ "\n  ",       /*  LSS N L  mark a label in the program */
/* WS_CALL    */ "\n \t",      /*  LST N L  call a subroutine to label */
/* WS_JMP     */ "\n \n",      /*  LSL N L  jump to label */
/* WS_JZ      */ "\n\t ",      /*  LTS N L  jump to label, if top of stack is zero */
/* WS_JN      */ "\n\t\t",     /*  LTT N L  jump to label, if top of stack is negative */
/* WS_RET     */ "\n\t\n",     /*  LTL      end subroutine, return to caller */
/* WS_END     */ "\n\n\n",     /*  LLL      end the program */
/* WS_PUTC    */ "\t\n  ",     /*  TLSS     output top of stack as character to stdout */
/* WS_PUTI    */ "\t\n \t",    /*  TLST     output top of stack as integer to stdout */
/* WS_READC   */ "\t\n\t ",    /*  TLTS     read a character from stdin */
/* WS_READI   */ "\t\n\t\t",   /*  TLTT     read an integer from stdin */
/* WS_DPRINT  */ "\t\t\n",     /*  TTL      prints the stack to the screen for debugging purposes */
/* WS_NONE    */ ""
};


/* instruction name */
const char *WS_INST_NAME[] =
{
    "WS_PUSH",
    "WS_DUP",
    "WS_COPY",
    "WS_SWAP",
    "WS_POP",
    "WS_SLIDE",
    "WS_ADD",
    "WS_SUB",
    "WS_MULT",
    "WS_DIV",
    "WS_MOD",
    "WS_STORE",
    "WS_RESTORE",
    "WS_LABEL",
    "WS_CALL",
    "WS_JMP",
    "WS_JZ",
    "WS_JN",
    "WS_RET",
    "WS_END",
    "WS_PUTC",
    "WS_PUTI",
    "WS_READC",
    "WS_READ",
    "WS_DPRINT",
    ""
};


/* longest WhiteSpace command (not counting param), 0 - 255 */
#define WS_MAX_COMMAND_LEN 4


/* length of the whitespace command */
size_t WS_INST_LEN[] =
{
/* WS_PUSH    */ 2,
/* WS_DUP     */ 3,
/* WS_COPY    */ 3,
/* WS_SWAP    */ 3,
/* WS_POP     */ 3,
/* WS_SLIDE   */ 3,
/* WS_ADD     */ 4,
/* WS_SUB     */ 4,
/* WS_MULT    */ 4,
/* WS_DIV     */ 4,
/* WS_MOD     */ 4,
/* WS_STORE   */ 3,
/* WS_RESTORE */ 3,
/* WS_LABEL   */ 3,
/* WS_CALL    */ 3,
/* WS_JMP     */ 3,
/* WS_JZ      */ 3,
/* WS_JN      */ 3,
/* WS_RET     */ 3,
/* WS_END     */ 3,
/* WS_PUTC    */ 4,
/* WS_PUTI    */ 4,
/* WS_READC   */ 4,
/* WS_READI   */ 4,

/* WS_DPRINT  */ 3,
/* WS_NONE    */ 0
};












int old_main (int argc, char **argv)
{
    /* storage container for file chars */
    char *file_contents;
    /* current character in file_contents */
    char current_char = '\0';

    /* program counter */
    uint64_t program_counter[STACK_LEN];
    uint64_t program_counter_index = 0;

    /* whitespace stack */
    wsInt program_stack[STACK_LEN];
    wsInt program_stack_index = 0;

    /* whitespace heap */
    hashMap *program_heap;

    /* active instruction variables */
    char instruction[WS_MAX_COMMAND_LEN];                   /* list of chars to compare with instructions */
    const uint8_t instruction_len = WS_MAX_COMMAND_LEN;     /* max length of instruction pointer */
    uint8_t instruction_count = 0;                          /* actual number of chars in pointer */

    /* error logging information */
    /* if last loop ran an instruction, set to true, otherwise assume false */
    bool instruction_flag;

    /* actively updates as different instructions are compared */
    /* used as a prerequisite to last_instruction*/
    WS_INST_INDEX inst_check = WS_NONE;
    /* hold index of the last ran instruction */
    WS_INST_INDEX last_instruction = inst_check;

    /* holds Human readable position of last run instruction */
    int32_t next_inst_line = g_line_num;
    int32_t next_inst_char = g_char_num;

    /* holds the error code returned be the last ran instruction */
    wsError err_code = WS_SUCCESS;

    /* runtime loop var */
    bool runtime = true;


    /* process console arguements, get file name */
    /* check that file console arguement was given */
    if (argc < CONARG_FILE + 1)
    {
        printf ("error: WSI expects one(1) console arguement. \nExample: \"wsi filename.ws<cr>\"\n");
        return EXIT_FAILURE;
    }


    /* attempt to get file contents */
    /* if cannot get file contenets return NULL, for example if file doesnt exsist */
    file_contents = fio_file_contents (argv[CONARG_FILE]);
    /* if raw_file_contents is equal to NULL, then the file could not be opened */
    if (file_contents == NULL)
    {
        printf ("error: could not open \"%s\"\n", argv[CONARG_FILE]);
        return EXIT_FAILURE;
    }


    /* start initializing variables for the interpretter */
    /* initialize the heap */
    program_heap = new_hashMap ();

    /* start program counter at 0 */
    program_counter[program_counter_index] = 0;

    /* first time run, reset/initiate instruction variables */
    instruction_flag = true;


    while (runtime)
    {
        /* file positioning and current character, overall incrementing through file */
        /* get current char */
        current_char = file_contents[program_counter[program_counter_index]];

        /* increment our location in the file */
        program_counter[program_counter_index]++;


        /* check for errors */
        /* check if character is EOF exit */
        if (current_char == '\0')
        {
            last_instruction = WS_NONE;
            err_code = WS_ERR_ENDOFFILE;
        }

        /* if the instruction pointer grows too long (normally a syntax error), throw error and quit */
        if (instruction_count > WS_MAX_COMMAND_LEN ||
            ((!runtime) && (instruction_count != 0)))
        {
            last_instruction = WS_NONE;
            err_code = WS_ERR_BADINSTRUCTION;
        }

        /* if an error is found YELL VIOLENTLY */
        /* if there was an error exectuting an instruction, log the error to the terminal and quit */
        if (err_code != WS_SUCCESS)
        {
            log_error (err_code, last_instruction, next_inst_line, next_inst_char);
            runtime = false;
            /* reset err_code to WS_SUCCESS as a backup */
            /* should not need to rely on this but JUSTINCASE */
            err_code = WS_SUCCESS;
            /* loop back to the start of the loop, and have loop recheck runtime */
            continue;
        }

        /* update error logging information */
        /* get line number and char in line for error logging */
        inc_cursor_position (current_char);


        /* ignore comments */
        /* if character isn't whitespace, early loop back */
        if (! (current_char == ' '  ||
               current_char == '\t' ||
               current_char == '\n' ))
        {
            /* return to start of loop */
            continue;
        }

        /* update variables when an instruction is ran */
        /* reset instruction variables */
        if (instruction_flag)
        {
            /* reset instruction variables */
            memset (instruction, 0, instruction_len * sizeof (instruction[0]));
            instruction_count = 0;
            instruction_flag = false;

            /* once next whitespace character shows up, save location of character */
            /* if an error occures, you have the base of the command */
            next_inst_line = g_line_num;
            next_inst_char = g_char_num - 1;
        }


        /* append current_char to our instruction char list */
        /* add new character to instruction string */
        instruction[instruction_count] = current_char; /* increment instruction */
        instruction_count++;


        /* compare our current instruction char list with defined instructions */
        /* if instruction doesnt match any defined WS_INST, set flag to false at end of if*/
        instruction_flag = true;

        /* instructions */
        /* for each instruction (defined in WS_INST) first change isnt_check to the instruction's index */
        /* then compare the current instruction with the defined WS_INST string. */
        /* if the 2 match, run the associated function */
        /* 
        if      (inst_check = WS_PUSH,    strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {   / * push a value onto stack * /
            err_code = wsi_push (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
        }
        else if (inst_check = WS_DUP,     strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {   / * duplicate top value of stack * /
            err_code = wsi_dup (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_COPY,    strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {   / * copy the Nth item to the top of the stack;  * /
            err_code = wsi_copy (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
        }
        else if (inst_check = WS_SWAP,    strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {   / * swap the top 2 items of the stack * /
            err_code = wsi_swap (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_POP,     strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {   / * pop/remove the top item on the stack * /
            err_code = wsi_pop (&program_stack_index);
        }
        else if (inst_check = WS_SLIDE,   strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {   / * slide/remove N number of items off of the stack, keeping the top element * /
            err_code = wsi_slide (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
        }
        else if (inst_check = WS_ADD,     strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {   / * add the top 2 items of the stack, destroy both, then push result to the top of the stack* /
            err_code = wsi_add (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_SUB,     strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_sub (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_MULT,    strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_mult (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_DIV,     strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_idiv (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_MOD,     strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_mod (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_STORE,   strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_store (program_stack, &program_stack_index, program_heap);
        }
        else if (inst_check = WS_RESTORE, strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_restore (program_stack, &program_stack_index, program_heap);
        }
        else if (inst_check = WS_LABEL,   strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_label (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
        }
        else if (inst_check = WS_CALL,    strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_call (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
        }
        else if (inst_check = WS_JMP,     strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_jump (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
        }
        else if (inst_check = WS_JZ,      strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_jump_zero (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
        }
        else if (inst_check = WS_JN,      strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_jump_negative (program_stack, &program_stack_index, file_contents, &program_counter[program_counter_index]);
        }
        else if (inst_check = WS_RET,     strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_ret (&program_counter_index);
        }
        else if (inst_check = WS_END,     strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_end (&runtime);
        }
        else if (inst_check = WS_PUTC,    strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_putc (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_PUTI,    strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_puti (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_READC,   strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_readc (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_READI,   strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            err_code = wsi_readi (program_stack, &program_stack_index);
        }
        else if (inst_check = WS_DPRINT,  strncmp (instruction, WS_INST[inst_check], WS_INST_LEN[inst_check]) == 0)
        {
            print_stack (program_stack, program_stack_index);
            err_code = WS_SUCCESS;
        }
        else
        {   / * show that no instruction is ran * /
            instruction_flag = false;
        }
        */

        /* when an instruction is ran we want to update last_instruction to reflect that */
        /* inst_check will match the last else if statement that was ran. ie the instruction that ran */
        /* so when an instruction is ran (anytime else isnt), update last_instruction */
        if (instruction_flag)
        {
            last_instruction = inst_check;
        }

    } /* end runtime loop */


    /* exit gracefully from the program */
    free (file_contents);
    free_hashMap (program_heap);

    /* after exitting, print new line because linux is adding a weird reverse color, percent sign if not??? */
    printf ("\n");

    /* return the errorcode, for somereason on linux it has weird side effects */ 
    exit (err_code);
}